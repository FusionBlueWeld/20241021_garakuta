

データ処理Webアプリを作りたい

ベースのフォルダ構成
M-I-E-R-I-O/  # ◀ プロジェクトのルートフォルダ
├── app/                  # ◀ Flaskアプリケーションの本体
│   ├── __init__.py         # Flaskアプリの初期化処理（Application Factory）
│   ├── routes.py           # URLのルーティング（例: @app.route）をここに集約
│   ├── data_processor.py   # CSVの読み込み、フィルタリング、データ抽出などの処理
│   ├── model_handler.py    # Tensorflowモデルの構築、学習、ファインチューニング処理
│   ├── settings_manager.py # FITTING/FUNCTIONタブのJSONファイルの読み書き、関数検証処理
│   │
│   ├── static/             # ◀ CSS, JavaScript, 画像などの静的ファイルを格納
│   │   ├── css/
│   │   │   └── style.css   # モダンなUIを実現するためのスタイルシート
│   │   ├── js/
│   │   │   ├── main.js     # 全ページ共通の処理（UIの初期化など）
│   │   │   ├── view.js     # 「VIEW」タブの動的処理（Plotly描画、フォーム連携）
│   │   │   ├── fitting.js  # 「FITTING」タブの動的処理（表の生成、APPLYボタン）
│   │   │   └── function.js # 「FUNCTION」タブの動的処理（行の追加/削除、APPLYボタン）
│   │   └── images/         # ロゴやアイコンなど
│   │
│   └── templates/          # ◀ HTMLテンプレート
│       └── index.html      # 全ての機能を持つメインページ
│
├── data/                 # ◀ デフォルトで提供するサンプルデータ
│   ├── Feature.csv
│   └── Target.csv
│
├── user_data/            # ◀ ユーザーが生成したデータを保存する場所 (※Git管理外)
│   ├── uploads/            # ユーザーがアップロードしたCSVファイルの一時保存場所
│   └── settings/           # FITTING/FUNCTIONで保存したJSONファイルの保存場所 (旧jsonフォルダ)
│
├── scripts/              # ◀ アプリ本体とは独立した補助スクリプト
│   └── sample_data_creator.py # ここに移動
│
├── run.py                # ◀ Flaskアプリケーションを起動するためのスクリプト
├── config.py             # アプリケーションの設定ファイル (SECRET_KEYなど)
└── requirements.txt      # 必要なPythonライブラリ一覧 (Flask, Tensorflow, pandasなど)


# ★SampleData_Creator.pyの役割

デバッグ用にサンプルデータを作成する（dataフォルダにFeature.csvとTarget.csv）
そのデータを用いて、main.pyの動作を検証する

作成するサンプルデータはレーザー溶接の加工条件（Feature）と加工結果（Target）のデータセットです
デバッグ用としてレーザー加工を採用しているが、アプリの機能はレーザー加工だけではなく、同様のデータ構造でプレス加工や切削加工にも転用することを見込んでいる

サンプルデータの加工条件（Feature）は、
'X1_speed'：レーザー走査速度
'X2_height'：レーザー焦点位置
'X3_power'：レーザー出力

加工結果（Target）は、
'Z_depth'：溶け込み深さ
'Z_width'：ビード幅

下記がそのデータを生成するコード例です

# SampleData_Creator.py

import numpy as np
import pandas as pd

# --- 外乱・ノイズ設定 (ここを調整してデータの「生っぽさ」を変更できます) ---
# 1. 中心位置のランダムオフセットの標準偏差
center_offset_std_x = 10.0  # 走査速度方向のずれの大きさ
center_offset_std_y = 0.2   # 焦点位置方向のずれの大きさ

# 2. 形状の非対称性係数
asymmetry_factor_y = 1.2    # 焦点がμ_yより大きい領域のsigmaを1.2倍する

# 3. 全体的なノイズの大きさ (正規分布の標準偏差)
noise_level_depth = 60.0    # 溶け込み深さのノイズの大きさ (最大値の約2%)
noise_level_width = 8.0     # ビード幅のノイズの大きさ (最大値の約1.8%)

# 4. 外れ値の発生確率と大きさ
outlier_probability = 0.01  # 1%の確率で外れ値が発生
outlier_magnitude_factor = 1.5 # 外れ値の大きさ（通常の最大値の1.5倍まで）

# --- 入力変数の刻み量を指定 ---
X1_speed_values = np.array([5, 10, 20, 50, 100, 200, 300, 400, 500, 600])
X2_height_values = np.array([-6, -5, -4, -3, -2, -1.5, -1, -0.5, 0, 0.5, 1, 2, 3, 4, 5, 6])
X3_power_values = np.array([500, 1000, 2000, 3000, 4000, 5000, 6000])

def asymmetric_gaussian_y(y, A, mu_y, sigma_y_rise, sigma_y_fall):
    """非対称なガウス分布のy項のみを計算する関数。"""
    sigma_y = np.where(y < mu_y, sigma_y_rise, sigma_y_fall)
    exponent = -(y - mu_y)**2 / (2 * sigma_y**2)
    return A * np.exp(exponent)

def calculate_bead_width(x, y, p):
    """ビード幅を計算する関数。各パラメータの効果を乗算でモデル化。"""
    A_width_scale = 8.5
    effect_p = p**0.4
    effect_x = np.exp(-x / 300) + 0.5
    effect_y = 1 + 0.03 * y**2
    return A_width_scale * effect_p * effect_x * effect_y

# --- 基本パラメータと外乱の適用 ---
max_depth = 3150
mu_y_base = 0
sigma_y_base = 3.0

# 1. 中心をランダムにずらす
mu_y_final = mu_y_base + np.random.normal(0, center_offset_std_y)

# 2. 非対称なsigmaを計算
sigma_y_rise, sigma_y_fall = sigma_y_base, sigma_y_base * asymmetry_factor_y

print("--- 生成条件 ---")
print(f"入力変数の組み合わせ数: {len(X1_speed_values)} (speed) x {len(X2_height_values)} (height) x {len(X3_power_values)} (power) = {len(X1_speed_values)*len(X2_height_values)*len(X3_power_values)} 点")
print(f"焦点位置の中心(オフセット適用後): mu_y={mu_y_final:.2f}")
print(f"Y方向の広がり(非対称): (rise={sigma_y_rise:.2f}, fall={sigma_y_fall:.2f})")

# --- 全組み合わせのグリッドを生成 ---
X, Y, P = np.meshgrid(X1_speed_values, X2_height_values, X3_power_values, indexing='ij')

# グリッド座標を1次元配列にフラット化
X_flat = X.flatten()
Y_flat = Y.flatten()
P_flat = P.flatten()

# --- Z_depth (溶け込み深さ) の計算 ---
# 1. 速度の効果: 指数関数で減衰
effect_x = np.exp(-X_flat / 300) + 0.5

# 2. 焦点位置による基本形状（0～1の範囲）を計算
depth_shape = asymmetric_gaussian_y(
    Y_flat, 1.0, mu_y_final, sigma_y_rise, sigma_y_fall
)

# 3. パワーの効果（0～1の範囲、飽和あり）を計算
power_effect_depth = (P_flat / np.max(X3_power_values))**0.7

# 最終的な溶け込み深さを計算
Z_depth = max_depth * effect_x * depth_shape * power_effect_depth

# --- Z_width (ビード幅) の計算 ---
Z_width = calculate_bead_width(X_flat, Y_flat, P_flat)

# --- 全体的なノイズの追加 ---
Z_depth += np.random.normal(0, noise_level_depth, Z_depth.shape)
Z_width += np.random.normal(0, noise_level_width, Z_width.shape)

# --- 外れ値の追加 ---
num_total_points = len(X_flat)
num_outliers = 0
for i in range(num_total_points):
    if np.random.rand() < outlier_probability:
        num_outliers += 1
        # この点を外れ値にする
        Z_depth[i] = max_depth * outlier_magnitude_factor * np.random.rand()
        Z_width[i] = 455 * outlier_magnitude_factor * np.random.rand()

if num_outliers > 0:
    print(f"{num_outliers}個の外れ値を生成しました。")

# --- クリッピングを除去 ---
Z_depth_final = Z_depth
Z_width_final = Z_width

# --- CSVファイルに保存 ---
main_ids = np.arange(num_total_points)

df_features = pd.DataFrame({
    'main_id': main_ids,
    'X1_speed': X_flat,
    'X2_height': Y_flat,
    'X3_power': P_flat
})
df_targets = pd.DataFrame({
    'main_id': main_ids,
    'Z_depth': Z_depth_final,
    'Z_width': Z_width_final
})

df_features.to_csv('Feature.csv', index=False)
df_targets.to_csv('Target.csv', index=False, float_format='%.4f')

print("\nCSVファイルが保存されました:")
print(" - Feature.csv")
print(" - Target.csv")


★ 以降、main.pyで実行されるアプリ仕様

# デザイン仕様

モダンでフラットデザインなUIとする
（背景は白っぽい色、ボタンなどオブジェクトの色ははっきりとした色を使用）
ある程度レスポンシブデザインを考慮する
WebUIのタイトルは「M-I-E-R-I-O」とする

# 技術スタック
サーバーサイドはpythonのflaskを使用する
フロントエンドはHTML、CSS、JavaScriptでゴリゴリ書く
機械学習に使用するフレームワークはTensorflowとする

# メインページの仕様
タイトルの下に
Feature：「テキストボックス」「ファイルボタン」
Target：「テキストボックス」「ファイルボタン」
を配置する。

ファイルボタンを押すとダイアログが開いて、CSVファイルを選択
パスはパラメータとして保持するが、テキストボックスにはファイル名のみを表示する

その下に
Production I/O：
という欄を作り、その欄の中に
Ch1:「LEDボタン」
Ch2:「LEDボタン」
・・・
Ch8:「LEDボタン」

を配置する

LEDボタンは等間隔に配置する
LEDはデフォルト灰色であるが、ボタンを押すと緑色になる

※Production I/O欄は発展機能のための前準備であり、この時点ではUIのみ作成する

－－－－－

その下には3つのタブを用意する

タブの名前は「VIEW」「FITTING」「FUNCTION」

「VIEW」タブの中には、Plotllyでグラフ表示するエリアを設ける
読み込んだFeatureのCSVファイルからヘッダー名を縦に並べ、その横にはドロップダウンボックスを作成する

ただし、FeatureのCSVのヘッダーから"main_id"のヘッダーだけは除外する

例）
Feature parameter
# name value
1 "X1_speed" 「ドロップダウンボックス」
2 "X2_height" 「ドロップダウンボックス」
・・・

ドロップダウンボックスには、
「Constant」「X_axis」「Y_axis」
を選択できるようにし、「Constant」の場合、任意の値を入れられるようにする

このドロップボックスで、どこかのヘッダーパラメータが「X_axis」、もしくは「Y_axis」を選んだ時、既にそれらが選ばれていたヘッダーのドロップダウンボックスから「X_axis」「Y_axis」の値は消去される（軸の選択が重複しないようにするため）

「Constant」が選択されているときに、値の入力がなければ、グラフは表示されない
すべてのパラメータで「Constant」「X_axis」「Y_axis」が入力されるまで、グラフが表示されない

同様に、その横にTargetのCSVファイルのフォームも設置する
例）
Target parameter
「ドロップダウンボックス」 のみ

Targetはドロップダウンボックスの中に、TargetのCSVファイルのヘッダーの選択肢を入れる
こちらも同様に、"main_id"のヘッダーは除去する
こちらも、パラメータの選択がない時は、グラフは表示されない


この下に、オーバーラップというラベルのついたトグルスイッチ（ON/OFF）、スイッチの横に「LEARNING」というボタンを設置する
オーバーラップのトグルスイッチは、デフォルトOFFで、FITTINGタブからの関数情報が渡されていなければ、ONにできないようにする
「LEARNING」ボタンは、このトグルスイッチがONにならないと押せないようにする（グレーにして無効化しておく）

また、「LEARNING」ボタンの横に「thresholdボタン」「テキストボックス」を設置する
thresholdボタン＋このテキストボックス、もトグルスイッチをONにしないと機能しないようにしておく

その下に、plotllyのグラフを描く
グラフはカラーマップのプロットを使った散布図
カラーマップはjetとする

軸設定として、Feature parameterのドロップダウンボックスのvalueが、
X_axisのヘッダーのデータがX軸、
Y_axisのヘッダーのデータがY軸、

Target parameterのドロップダウンボックスで選択したヘッダーがZ軸（カラーマップ表示）となるようにする

各軸の表示最大値と最小値は、入力されるデータに応じてフレキシブルに変更される

Feature parameter、Target parameterが複数あり、上のフォームで選択を変えたとき、即時自動でグラフには反映される
（もちろん、フォーム入力が消されれば、グラフも表示されなくなる）

Feature parameterで「X_axis」「Yaxis」以外のヘッダーパラメータで、「Constant」となっていて任意の値が設定されているとき、そのヘッダー列からその値の行のみが抽出される
この「Constant」の任意値設定が複数ある時、それはAND条件で抽出される

－－－－－

次に、「FITTING」タブについて

タブの中の上の方に「LOAD」ボタンを設置し、以降の状態を保存したjsonファイルをロードできるようにする
LOADボタンの横に「線形結合」「乗積」のトグルスイッチを設定する（デフォルトは「線形結合」）
ダイアログが開いて、jsonフォルダが開き、以下で設定する{FITTING}の入ったファイルを抽出して、選択できるようにする

ロードしたFeatureとTargetのCSVファイルのそれぞれのヘッダを、列と行に並べた表を作成する
横方向の軸にはTargetヘッダーを並べ、
縦方向の軸にはFeatureヘッダーを並べる

その交差セルには、それぞれドロップダウンボックスを配置する
ドロップダウンボックスにはガイド表示で「--関数を選択--」と書かれている

ヘッダーの数が多く、表が大きくなる時は、タブの中でスクロールできるようにする

この表の下に「APPLY」ボタンを設置する
「APPLY」ボタンを押すと、下記2つの動作を実行
１．
この表で選択した関数の状態がjsonファイルで保存される
jsonファイルは、jsonフォルダ内に保存される
この時ロードしているFeatureCSVファイルとTargetCSVファイルのパスも保存しておく
（どのファイルがロードされた時の設定なのかを紐づけるため）

このjsonファイルは「settings/{FITTING}_yyyymmddHHMMSS.json」で保存され、履歴が残るようにする

２．
１．のjsonファイル保存を実行したとき、下記の条件が満たされていれば、続きの処理が実行される

この表のすべての欄が何らかの定義された関数が入力されているときのみ、下記が実行される
Target変数の関数が作成される

例えば、
LOADボタン横のトグルスイッチが「線形結合」のとき、

Target変数：T1、T2が設定されていて、
Feature変数：F1、F2、F3が設定されていたとすると、

T1=「F1のT1列設定関数」+「F2のT1列設定関数」+「F3のT1列設定関数」
T2=「F1のT2列設定関数」+「F2のT2列設定関数」+「F3のT2列設定関数」
（表におけるその列で設定した各関数に対応）

もしトグルスイッチが「乗積」であれば、
T1=「F1のT1列設定関数」*「F2のT1列設定関数」*「F3のT1列設定関数」
T2=「F1のT2列設定関数」*「F2のT2列設定関数」*「F3のT2列設定関数」

という形でTarget変数が表現される

そして、このTarget変数の表現関数で計算された結果を、VIEWタブへ渡す

※ここからは、Target変数の表現関数が渡された後のVIEWタブでの処理を示す

オーバーラップのトグルスイッチを、ONにできるようになる
オーバーラップスイッチがONになったら、

Feature parameter欄とTarget parameter欄で設定された変数に沿って、plotlyで表示されている範囲のカラーマップを作成し、表示されてる散布図グラフに重ねて表示する
（ただし、実データが上レイヤー、計算結果が下レイヤーで重ねる、また計算結果のカラーマップ透明度は35%とする）

この時に、カラーマップが表示される範囲は、CSVデータが表示される範囲が優先される
そのため、計算されたカラーマップのデータも、CSVデータとうまくオーバーラップする範囲以外は除去しておく（計算負荷軽減のため）

これらのカラーマップは、Feature parameter、Target parameterのフォーム入力を変更すると、CSVデータの表示変更と合わせて、同じく即時変更される

オーバーラップのスイッチをOFFにするとカラーマップは消える

例えば、
Feature parameterが、F1：X_axis、F2：Y_axis、F3：const（value=1000）、
Target parameterが、T1を選択
とするとき、

渡されたT1の表現関数（T1=「F1のT1列設定関数」+「F2のT1列設定関数」+「F3のT1列設定関数」とする）に沿って、その時にグラフ表示される範囲で、
（F1=X_axis,F2=Y_axis,F3=const, T1）の値が計算され、その結果がカラーマップとしてX軸にF1、Y軸にF2、強度T1としてグラフ内に重ねて表示される

トグルスイッチがオンできるようになったら、その横の「LEARNING」ボタンが押せるようになる

「LEARNING」ボタンを押すと下記の処理が実行される
マルチパーセプトロンの3層の隠れ層を持つニューラルネットワークが、渡された表現関数のデータ値を学習する
例えば、
入力変数：F1,F2,F3
出力変数（正解ラベル）：T1,T2
として、機械学習を行う

この時に、機械学習の精度がよくなる程度に、カラーマップとして使用される値の量を計算しておく

次に、このモデルを保存しておき、実際のデータを使ってファインチューニングを行う

使用するデータは、
入力変数：Feature.csvのパラメータ
出力変数（正解ラベル）：Target.csvのパラメータ

ファインチューニングを行った最終的な学習結果を、同じようにカラーマップで表示する

学習中、その下にゲージバーが現れて、学習の進捗を％で演出する表示を追加する
計算値と実データの学習量を合わせて100%として、その学習過程を見えるようにする
ゲージバーが100％になると「Complete！」という文字が、ゲージバーに出て、その後2秒経って、文字と一緒にゲージバーが消える

学習中、その進捗がおよそ20%毎に、学習途中のカラーマップを計算し、学習の進行と共に、カラーマップが学習によって変化していく様子を表示する

また、トグルスイッチがオンできるようになったら、「LEARNING」ボタンの横のthresholdボタン＋テキストボックス、が機能するようになる
テキストボックスに入力した値は、カラーマップとして表示されているTarget parameterの値と対応する

例えば、
Target parameter欄で、Z_depthというparameterを選択しているとき、
カラーマップにはZ_depthのカラーマップが表示されており、
テキストボックスに入力された値となる座標をカラーマップ上で繋いで、黒の波線を引いて表示する
この波線が、このアプリで分析する加工の、結果閾値（OK/NG）となる

このthresholdボタンはこの破線の表示、非表示を制御する
一度押すと緑色に点灯し、波線が表示される
もう一度押すと、点灯が消え、波線も消える
テキストボックスの値の変更はリアルタイムに反映され、値を変えるとすぐにグラフの波線位置も変更される

－－－－－

次に「FUNCTION」タブの設定

ここも上の方に「LOAD」ボタンを付けておく
タブの中の上の方に「LOAD」ボタンを設置し、以降の状態を保存したjsonファイルをロードする

ダイアログが開いて、jsonフォルダが開き、以下で設定する{FUNCTION}の入ったファイルを抽出して、選択できるようにする
# name equation parameters
1 「テキストボックス」「テキストボックス」「テキストボックス」

という表示をデフォルトにする 
その上に「+Add」「-Del」というボタンも設置しておき、入力関数の行を増やしたり減らしたりできる

例えば、
# name equation parameters
1 関数1 a*x+b a=1, b=3
という入力になる

複雑な関数となるとき、その表記ルールも設計してください

同様に、このタブの下に「APPLY」ボタンを付けておき、
１．
「APPLY」ボタンが押されたとき、記入された関数が表記ルールに沿っているかどうかをチェックする機能も実装して
表記ルールから外れた場合、エラーでAPPLY実行できないようにする

２．
「APPLY」ボタンを押すとこの表で選択した関数の状態がjsonファイルで保存される
jsonファイルは、jsonフォルダ内に保存される
この時ロードしているFeatureCSVファイルとTargetCSVファイルのパスも保存しておく
（どのファイルがロードされた時の関数なのかを紐づけるため）
このjsonファイルは「settings/{FUNCTION}_yyyymmddHHMMSS.json」で保存され、履歴が残るようにする

FUNCTIONタブで設定した関数が、FITTINGタブの関数を選択ドロップダウンボックスに選択肢として現れる

SampleData_Creator.pyで、各種データ生成に用いた関数は予めデフォルト関数として登録しておく
関数名	式	パラメータ
Func_X1_Zdepth	exp(-x / scale) + offset	scale=300, offset=0.5
Func_X2_Zdepth	A * exp(-(y - mu_y)^2 / (2 * sigma_y^2))	A=1.0, mu_y=mu_y_final, sigma_y_rise=3.0, sigma_y_fall=3.0 * 1.2
Func_X3_Zdepth	(p / max_power)^exponent	max_power=6000, exponent=0.7
Func_X1_Zwidth	exp(-x / scale) + offset	scale=300, offset=0.5
Func_X2_Zwidth	1 + coefficient * y^2	coefficient=0.03
Func_X3_Zwidth	p^exponent	exponent=0.4

－－－－－

# 全体を通した指示
処理はできるだけフロントエンドで実行し、
計算が重たい、またはファイル保存など永続的な記録が必要になる場合はバックエンドのPythonで処理を行うようにする
コード内のコメントは日本語で記載して

SampleData_Creator.pyで生成されたテストデータ（Feature.csv、Target.csv）を用いて、このアプリの機能のデバッグを行う


開発の現実的なステップとテスト仕様
下記の開発ステップに沿って、コードを作成し、各マイルストーンとなるステップでテストコードも実装し、デバッグを行う。テストをパスしたとき、次の開発ステップへ遷移する。


【ステップ1】 アプリケーションの骨格構築とサーバー起動
目標: まずはWebアプリとして最低限の形を作り、ブラウザに画面を表示させる。
* 開発内容:
    1. 提案されたフォルダ構成を作成する。
    2. requirements.txtにFlask, pandas, numpyを記述し、仮想環境にインストールする。
    3. run.pyを作成し、Flaskアプリケーションを起動するコードを記述する。
    4. app/__init__.pyでFlaskのApplication Factoryパターンを用いてアプリのインスタンスを生成する。
    5. app/routes.pyにルートURL(/)に対するルートを定義し、index.htmlをレンダリングする。
    6. app/templates/index.htmlに、タイトル「M-I-E-R-I-O」と、3つのタブ（VIEW, FITTING, FUNCTION）の骨格をHTMLで作成する。
    7. scripts/sample_data_creator.pyを実行し、dataフォルダにFeature.csvとTarget.csvを生成しておく。
* テスト仕様:
    * python run.pyコマンドでエラーなくWebサーバーが起動すること。
    * ブラウザで http://127.0.0.1:5000 にアクセスし、「M-I-E-R-I-O」というタイトルと3つのタブが表示されること。
    * dataフォルダ内に、Feature.csvとTarget.csvが存在すること。

【ステップ2】 CSVファイルのアップロードと静的なグラフ表示
目標: ユーザーがCSVファイルを指定し、そのデータに基づいた基本的な3D散布図を表示できるようにする。
* 開発内容:
    1. フロントエンド (:
        * VIEWタブ内に、Feature/Targetのファイル選択ボタンとテキストボックスを配置する。
        * ファイルを選択すると、ファイル名がテキストボックスに表示されるJavaScriptを実装する。
        * Plotly.jsライブラリをindex.htmlに読み込ませる。
        * グラフ描画用の<div id="plot-area"></div>を配置する。
    2. バックエンド (:
        * ファイルアップロードを受け付けるエンドポイント(API)をroutes.pyに作成（例: /api/upload）。
        * アップロードされたCSVファイルをuser_data/uploads/に保存し、Pandasで読み込む。
        * 読み込んだデータをJSON形式でフロントエンドに返す処理をdata_processor.pyに実装する。
    3. 連携 (:
        * ファイルが選択されたら、Ajax（Fetch API）でバックエンドにファイルを送信し、返ってきたデータを使ってPlotlyの3D散布図を描画する。
        * この段階では軸は固定でOK（例: X軸はFeatureの1列目、Y軸は2列目、Z軸(色)はTargetの1列目）。
* テスト仕様:
    * VIEWタブの「ファイルボタン」でFeature.csvとTarget.csvを選択できること。
    * ファイルを選択すると、テキストボックスにそれぞれのファイル名が表示されること。
    * 両方のファイルを選択後、plot-areaにPlotlyの3D散布図が表示されること。
    * user_data/uploadsフォルダにアップロードしたCSVファイルが保存されていること。

【ステップ3】 インタラクティブなグラフ操作機能
目標: ユーザーが自由に軸を選択し、データをフィルタリングしてグラフを動的に変更できるようにする。
* 開発内容:
    1. フロントエンド (:
        * CSV読み込み成功後、ヘッダー名（main_idを除く）を使ってVIEWタブのパラメータ選択フォーム（ドロップダウン等）を動的に生成する。
        * ドロップダウン（Constant, X_axis, Y_axis）の選択肢と、Constant用の値入力欄を実装する。
        * フォームの選択内容が変更されるたびに、グラフを再描画するイベントリスナーを実装する。
        * X_axisとY_axisが重複しないように制御するロジックを追加する。
        * Constantが指定された場合、表示するデータをJavaScript上でフィルタリングする。
        * 必須項目（X/Y軸、Target）が全て設定されるまでグラフを表示しないようにする。
* テスト仕様:
    * Feature.csv読み込み後、パラメータ欄にX1_speed, X2_height, X3_powerが表示されること。
    * X1_speedをX_axis、X2_heightをY_axis、TargetをZ_depthに選択すると、対応するグラフが表示されること。
    * X3_powerをX_axisに変更すると、X1_speedの選択がX_axisでなくなる（例: Constantに戻る）こと。
    * X3_powerをConstant、値を3000に設定すると、P_flat=3000のデータ点のみでグラフが再描画されること。
    * 必須項目を一つでも未選択にすると、グラフが消えること。

【ステップ4】 「FUNCTION」タブと設定保存機能
目標: ユーザーがカスタム関数を定義し、JSONファイルとして保存・読込できるようにする。
* 開発内容:
    1. フロントエンド (:
        * FUNCTIONタブのUI（テーブル、+Add/-Delボタン、APPLY/LOADボタン）を実装する。
        * +Add/-Delボタンで入力行を増減させる機能を実装する。
        * sample_data_creator.pyで使われている関数をデフォルト値として表示する。
    2. バックエンド (:
        * APPLY時にテーブルの内容をJSONで受け取り、検証後、user_data/settings/{FUNCTION}_yyyymmddHHMMSS.jsonとして保存するAPI（例: /api/save_function）を実装する。
        * 関数の表記ルール（例: a*x+b）をチェックするバリデーション機能をsettings_manager.pyに実装する。
        * LOAD時に保存済みJSONファイルを読み込み、内容を返すAPIを実装する。
* テスト仕様:
    * FUNCTIONタブにデフォルト関数が表示されていること。
    * +Addと-Delボタンが正しく動作すること。
    * 関数を編集してAPPLYを押すと、user_data/settingsにタイムスタンプ付きのJSONファイルが生成されること。
    * 不正な数式（例: a**x+）を入力してAPPLYを押すと、エラーメッセージが表示され、ファイルは保存されないこと。
    * LOADボタンでJSONファイルを選択すると、テーブルの内容が復元されること。

【ステップ5】 「FITTING」タブとモデル構築機能
目標: FUNCTIONタブで定義した関数を使い、FeatureとTargetの関係を表現する数式モデルを組み立て、保存できるようにする。
* 開発内容:
    1. フロントエンド (:
        * FITTINGタブのUI（テーブル、トグルスイッチ、ボタン）を実装する。
        * CSV読み込み後、ヘッダーを元に動的にテーブル（行:Feature, 列:Target）を生成する。
        * 各セルのドロップダウンに、FUNCTIONタブで定義された関数名を動的にセットする（API経由で取得）。
    2. バックエンド (:
        * user_data/settingsから関数定義JSONを読み込み、関数名リストを返すAPI（例: /api/get_functions）を実装する。
        * APPLY時にテーブルの状態をJSONで受け取り、{FITTING}_...jsonとして保存するAPIを実装する。
* テスト仕様:
    * CSV読み込み後、FITTINGタブのテーブルの行列に正しいヘッダー名が表示されること。
    * 各セルのドロップダウンに、FUNCTIONタブで定義した関数名が表示されること。
    * 全てのセルに関数を割り当てAPPLYを押すと、{FITTING}_...jsonファイルが保存されること。
    * 一つでも未選択のセルがある状態でAPPLYを押しても、エラーが表示され、モデル構築処理（次のステップ）に進まないこと。

【ステップ6】 モデルのオーバーラップ表示機能
目標: FITTINGタブで構築した数式モデルの計算結果を、VIEWタブの実データグラフに重ねて可視化する。
* 開発内容:
    1. バックエンド (:
        * モデルの計算結果（カラーマップ用の面データ）を返すAPI（例: /api/calculate_surface）を実装する。このAPIは、現在の軸設定・Constant値・FITTINGモデルの情報を受け取る。
        * API内部では、FITTING/FUNCTIONのJSONを読み解き、数式を再構築し、指定された範囲のグリッドデータに対して値を計算する。
    2. フロントエンド (:
        * FITTINGタブでAPPLYが成功したら、「オーバーラップ」スイッチを有効化する。
        * スイッチがONになったら、APIに計算をリクエストし、返ってきた面データをPlotlyのsurface（またはheatmap）として、既存の散布図に透明度35%で重ねて描画する。
        * VIEWタブの軸設定などが変更されたら、再度APIを呼び出してオーバーラップ表示を更新する。
* テスト仕様:
    * FITTINGでAPPLYするまで、「オーバーラップ」スイッチが押せないこと。
    * APPLY後、スイッチが押せるようになり、ONにすると半透明のカラーマップが散布図の下に表示されること。
    * VIEWタブで軸やConstant値を変更すると、カラーマップも追従して更新されること。
    * スイッチをOFFにするとカラーマップが消えること。

【ステップ7】 機械学習と学習過程の可視化
目標: FITTINGモデルを初期値としてNNモデルを学習させ、その過程と結果をVIEWタブで可視化する。
* 開発内容:
    1. バックエンド (:
        * tensorflowをrequirements.txtに追加する。
        * 学習を開始するAPI（例: /api/start_learning）と、進捗を返すAPI（例: /api/learning_progress）を実装する。学習は重い処理なので、非同期実行（例: CeleryやFlaskのバックグラウンドタスク）を検討する。
        * model_handler.pyにNNモデルの構築、FITTINGモデルによる事前学習、実データによるファインチューニングのロジックを実装する。
    2. フロントエンド (:
        * オーバーラップ表示後、「LEARNING」ボタンを有効化する。
        * ボタンクリックで学習開始APIを呼び出し、プログレスバーを表示する。
        * setInterval等で定期的に進捗APIをポーリングし、プログレスバーとオーバーラップ表示のカラーマップを更新する。
        * 学習完了後、「Complete!」表示とゲージバーの消去処理を実装する。
* テスト仕様:
    * 「LEARNING」ボタンが適切なタイミングで有効化されること。
    * ボタンを押すとプログレスバーが表示され、進捗に合わせてバーが伸びること。
    * 学習中にカラーマップが徐々に変化していく様子が確認できること。
    * 学習完了後、「Complete!」が表示され、一定時間後に消えること。

【ステップ8】 閾値表示とUI/UXの仕上げ
目標: 閾値の可視化機能を追加し、アプリ全体のデザインと使いやすさを向上させる。
* 開発内容:
    1. フロントエンド (:
        * 「thresholdボタン」とテキストボックスを実装し、適切なタイミングで有効化する。
        * テキストボックスの値が変更されると、Plotlyの等高線機能(contour)を使い、カラーマップ上に黒の波線を描画・更新する。
        * ボタンで線の表示/非表示を切り替える。
    2. 全体:
        * static/css/style.cssを本格的に記述し、モダンでフラットなデザインを適用する。
        * Production I/O欄のUIを実装する。
        * CSSのメディアクエリ等を使い、スマホなどの小さい画面でもレイアウトが崩れないようにレスポンシブ対応を行う。
* テスト仕様:
    * Threshold関連UIが適切なタイミングで有効化されること。
    * テキストボックスに数値を入力すると、グラフ上に黒い波線が表示され、値の変更に追従すること。
    * Thresholdボタンで線の表示/非表示が切り替えられること。
    * PCとスマホ（ブラウザの開発者ツールでシミュレート）で表示し、著しいレイアウト崩れがないことを確認すること。
